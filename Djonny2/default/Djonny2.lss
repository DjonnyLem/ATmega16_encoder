
Djonny2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000912  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  00000912  000009a6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000015  0080006e  0080006e  000009b4  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000009b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00001080  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000080  00000000  00000000  00001105  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000002ff  00000000  00000000  00001185  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000d70  00000000  00000000  00001484  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000446  00000000  00000000  000021f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000123e  00000000  00000000  0000263a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000340  00000000  00000000  00003878  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000386  00000000  00000000  00003bb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000f8f  00000000  00000000  00003f3e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000092  00000000  00000000  00004ecd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
   4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
   8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
   c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

00000054 <convert_HD44780>:
  54:	41 a0 42 a1 e0 45 a3 a4 a5 a6 4b a7 4d 48 4f a8     A.B..E....K.MHO.
  64:	50 43 54 a9 aa 58 e1 ab ac e2 ad ae ad af b0 b1     PCT..X..........
  74:	61 b2 b3 b4 e3 65 b6 b7 b8 b9 ba bb bc bd 6f be     a....e........o.
  84:	70 63 bf 79 e4 78 e5 c0 c1 e6 c2 c3 c4 c5 c6 c7     pc.y.x..........

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf e5       	ldi	r28, 0x5F	; 95
  9a:	d4 e0       	ldi	r29, 0x04	; 4
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	10 e0       	ldi	r17, 0x00	; 0
  a2:	a0 e6       	ldi	r26, 0x60	; 96
  a4:	b0 e0       	ldi	r27, 0x00	; 0
  a6:	e2 e1       	ldi	r30, 0x12	; 18
  a8:	f9 e0       	ldi	r31, 0x09	; 9
  aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
  ac:	05 90       	lpm	r0, Z+
  ae:	0d 92       	st	X+, r0
  b0:	ae 36       	cpi	r26, 0x6E	; 110
  b2:	b1 07       	cpc	r27, r17
  b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
  b6:	10 e0       	ldi	r17, 0x00	; 0
  b8:	ae e6       	ldi	r26, 0x6E	; 110
  ba:	b0 e0       	ldi	r27, 0x00	; 0
  bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
  be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
  c0:	a3 38       	cpi	r26, 0x83	; 131
  c2:	b1 07       	cpc	r27, r17
  c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
  c6:	0e 94 89 00 	call	0x112	; 0x112 <main>
  ca:	0c 94 87 04 	jmp	0x90e	; 0x90e <_exit>

000000ce <__bad_interrupt>:
  ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <Init_Port>:
//	LED_PORT |= 1<<LED1; //УСТАНАВЛИВАЕМ В БИТЕ ПОРТА D ВЫСОКИЙ УРОВЕНЬ

//	Enc_DDR &= (~(1<<Enc_A) | (1<<Enc_B)); // БИТ ПОРТА D НА ВХОД
//	Enc_PORT &= (~(1<<Enc_A) | (1<<Enc_B)); //УСТАНАВЛИВАЕМ В БИТЕ ПОРТА D ПОДТЯЖКУ
	
	DDRA = 0b00000000; // БИТ ПОРТА A НА ВХОД канал АЦП
  d2:	1a ba       	out	0x1a, r1	; 26
	PORTA |=(1<<PA0); //= 0b00000001; //УСТАНАВЛИВАЕМ В БИТЕ ПОРТА A ПОДТЯЖКУ
  d4:	d8 9a       	sbi	0x1b, 0	; 27
}	
  d6:	08 95       	ret

000000d8 <LCD_DATA>:
	
void LCD_DATA (ADC_value)
{
  d8:	cf 93       	push	r28
  da:	df 93       	push	r29
  dc:	ec 01       	movw	r28, r24
    //    value = pBuf;

		//Flag.FADC == 0;
		//LCDclear();
		
		LCDstringXY("Count:",0,0);
  de:	80 e6       	ldi	r24, 0x60	; 96
  e0:	90 e0       	ldi	r25, 0x00	; 0
  e2:	60 e0       	ldi	r22, 0x00	; 0
  e4:	40 e0       	ldi	r20, 0x00	; 0
  e6:	0e 94 54 01 	call	0x2a8	; 0x2a8 <LCDstringXY>
		LCDstringXY("Volt:",0,1);
  ea:	87 e6       	ldi	r24, 0x67	; 103
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	60 e0       	ldi	r22, 0x00	; 0
  f0:	41 e0       	ldi	r20, 0x01	; 1
  f2:	0e 94 54 01 	call	0x2a8	; 0x2a8 <LCDstringXY>
		
		//BCD_3("123");
		//LCDstring_of_sramXY(pBuf,7,0);
		
		BCD_4Int(ADC_value);
  f6:	ce 01       	movw	r24, r28
  f8:	0e 94 d6 02 	call	0x5ac	; 0x5ac <BCD_4Int>
		LCDstring_of_sramXY(pBuf,7,1);
  fc:	80 91 7d 00 	lds	r24, 0x007D
 100:	90 91 7e 00 	lds	r25, 0x007E
 104:	67 e0       	ldi	r22, 0x07	; 7
 106:	41 e0       	ldi	r20, 0x01	; 1
 108:	0e 94 8b 01 	call	0x316	; 0x316 <LCDstring_of_sramXY>
		//BCD_5Int(value_ADC);
		//LCDstring_of_sramXY(pBuf,8,1);
		
        //asm("nop");
		//LCDstringXY(EncValueValue,5,1);
};
 10c:	df 91       	pop	r29
 10e:	cf 91       	pop	r28
 110:	08 95       	ret

00000112 <main>:
/********************************************************************
* 	Основной цикл
*********************************************************************/

int main(void)
{
 112:	ef 92       	push	r14
 114:	ff 92       	push	r15
 116:	cf 93       	push	r28
 118:	df 93       	push	r29
	LCDinit();      //Инициализация LCD
 11a:	0e 94 bb 01 	call	0x376	; 0x376 <LCDinit>
    Init_Port();		//Инициализация портов
 11e:	0e 94 69 00 	call	0xd2	; 0xd2 <Init_Port>
	//Init_TIMER0_COMP(); //Инициализация таймера по совпадению
	Init_ADC();			//Инициализация АЦП
 122:	0e 94 ba 00 	call	0x174	; 0x174 <Init_ADC>
	//LCD_DATA();
	pBuf=BCD_GetPointerBuf();//иннициализация переменной pBuf для вывода данных на LCD
 126:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <BCD_GetPointerBuf>
 12a:	90 93 7e 00 	sts	0x007E, r25
 12e:	80 93 7d 00 	sts	0x007D, r24
	//OCR0 = COUNT_TIMER; //Заносим регистр значение счетчика
    //TCNT0 =0;			//Сбрасываем таймер
    sei();								// Общее разрешение прерываний
 132:	78 94       	sei
	while(1)
	{
		asm("nop");
 134:	00 00       	nop
		
		
		if(ADCSRA&(1<<ADIF))
 136:	34 9b       	sbis	0x06, 4	; 6
 138:	fd cf       	rjmp	.-6      	; 0x134 <main+0x22>
		{
			low_ADC = ADCL;
 13a:	84 b1       	in	r24, 0x04	; 4
 13c:	80 93 6f 00 	sts	0x006F, r24
			high_ADC = ADCH;
 140:	95 b1       	in	r25, 0x05	; 5
 142:	90 93 6e 00 	sts	0x006E, r25
			ADC_value = high_ADC*256+low_ADC;		
 146:	20 e0       	ldi	r18, 0x00	; 0
 148:	e9 01       	movw	r28, r18
 14a:	7e 01       	movw	r14, r28
 14c:	e8 0e       	add	r14, r24
 14e:	f1 1c       	adc	r15, r1
 150:	f0 92 80 00 	sts	0x0080, r15
 154:	e0 92 7f 00 	sts	0x007F, r14
			
			ADCSRA|=(1<<ADIF);	
 158:	34 9a       	sbi	0x06, 4	; 6
			LCD_DATA();
 15a:	0e 94 6c 00 	call	0xd8	; 0xd8 <LCD_DATA>
 15e:	ea cf       	rjmp	.-44     	; 0x134 <main+0x22>

00000160 <Init_TIMER0_COMP>:
//			  7       6       5       4       3      2        1	
//	TCCR0 = FOC00 | WGM00 | COM01 | COM00 | CS02 | CS01 |	CS00

	//CS02,CS01,CS00 ПРЕСКАЛЕР 101 -1024; 001 -0; 010 -8; 011 -64; 100 -256
	//(1<<WGM01) | (0<<WGM00) CTC РЕЖИМ
	TCCR0 |=(0<<CS02)|(0<<CS01)|(1<<CS00)|(1<<WGM01)|(0<<WGM00);  	
 160:	83 b7       	in	r24, 0x33	; 51
 162:	89 60       	ori	r24, 0x09	; 9
 164:	83 bf       	out	0x33, r24	; 51
																			


//TIMSK 
	//; TOIE01- РАЗРЕШАЕТ ПРЕРЫВАНИЕ ПО ПЕРЕПОЛНЕНИЮ, 0- ЗАПРЕЩАЕТ / OCIE0 1- РАЗРЕШАЕТ ПРЕРЫВАНИЕ ПО СОВПАДЕНИЮ, 0- ЗАПРЕЩАЕТ
	TIMSK |=(0<<TOIE0)|(1<<OCIE0); 
 166:	89 b7       	in	r24, 0x39	; 57
 168:	82 60       	ori	r24, 0x02	; 2
 16a:	89 bf       	out	0x39, r24	; 57
	
    TIFR |= (1<<OCF0)|(0<<TOV0);
 16c:	88 b7       	in	r24, 0x38	; 56
 16e:	82 60       	ori	r24, 0x02	; 2
 170:	88 bf       	out	0x38, r24	; 56
}
 172:	08 95       	ret

00000174 <Init_ADC>:
*********************************************************************/


void Init_ADC(void) // Настройка АЦП
{
	ADMUX &=~(1 << REFS1); //  берется напряжение питания
 174:	3f 98       	cbi	0x07, 7	; 7
	ADMUX &=~(1 << REFS0); //  берется напряжение питания
 176:	3e 98       	cbi	0x07, 6	; 7
	ADMUX &=~(1 << MUX0); //  MUX0 0000 -канал ADC0	
 178:	38 98       	cbi	0x07, 0	; 7
	ADMUX &=~(1 << MUX1); //  MUX1 0000 -канал ADC0	
 17a:	39 98       	cbi	0x07, 1	; 7
	ADMUX &=~(1 << MUX2); //  MUX2 0000 -канал ADC0	
 17c:	3a 98       	cbi	0x07, 2	; 7
	ADMUX &=~(1 << MUX3); //  MUX3 0000 -канал ADC0	
 17e:	3b 98       	cbi	0x07, 3	; 7
	ADMUX &=~(1 << MUX4); //  MUX3 0000 -канал ADC0
 180:	3c 98       	cbi	0x07, 4	; 7
	
	ADCSRA |=(1 << ADEN);  // Разрешение АЦП
 182:	37 9a       	sbi	0x06, 7	; 6
	ADCSRA |=(1 << ADPS2)|(1 << ADPS1)|(1<<ADPS0);// Предделитель на 128 (частота АЦП 64kHz)		
 184:	86 b1       	in	r24, 0x06	; 6
 186:	87 60       	ori	r24, 0x07	; 7
 188:	86 b9       	out	0x06, r24	; 6
	ADCSRA |=(1 << ADATE);  // Непрерывный режим работы АЦП
 18a:	35 9a       	sbi	0x06, 5	; 6
	//ADCSRA |=(1 << ADIE); // Разрешение прерывания от АЦП	
	ADCSRA |=(1 << ADSC);  // Запуск преобразования
 18c:	36 9a       	sbi	0x06, 6	; 6
				 
		

}
 18e:	08 95       	ret

00000190 <OutPin>:
{
	#ifdef  LCD_8BIT
			DDDR =0xFF;
			DPORT=0;
	#else
			DDDR |=  (1<<DB7)|(1<<DB6)|(1<<DB5)|(1<<DB4);
 190:	87 b3       	in	r24, 0x17	; 23
 192:	80 6f       	ori	r24, 0xF0	; 240
 194:	87 bb       	out	0x17, r24	; 23
			DPORT&=~((1<<DB7)|(1<<DB6)|(1<<DB5)|(1<<DB4));
 196:	88 b3       	in	r24, 0x18	; 24
 198:	8f 70       	andi	r24, 0x0F	; 15
 19a:	88 bb       	out	0x18, r24	; 24
	#endif
}
 19c:	08 95       	ret

0000019e <Strob>:
			DPORT|=  (1<<DB7)|(1<<DB6)|(1<<DB5)|(1<<DB4);
	#endif
}
static void Strob(void)             //Вкл/выкл строба Е
{
	CPORT|=(1<<E);//Включили строб.
 19e:	c0 9a       	sbi	0x18, 0	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1a0:	82 e0       	ldi	r24, 0x02	; 2
 1a2:	8a 95       	dec	r24
 1a4:	f1 f7       	brne	.-4      	; 0x1a2 <Strob+0x4>
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <Strob+0xa>
	_delay_us(1);
	CPORT&=~(1<<E);//Выключили строб.
 1a8:	c0 98       	cbi	0x18, 0	; 24
}
 1aa:	08 95       	ret

000001ac <Busy_flag>:
	#endif
	
	HiPin();
}
static void Busy_flag(void)		    //Проверка флага занятости
{
 1ac:	1f 93       	push	r17
{
	#ifdef  LCD_8BIT
			DDDR =0;
			DPORT=0xFF;
	#else
			DDDR &=~((1<<DB7)|(1<<DB6)|(1<<DB5)|(1<<DB4));
 1ae:	87 b3       	in	r24, 0x17	; 23
 1b0:	8f 70       	andi	r24, 0x0F	; 15
 1b2:	87 bb       	out	0x17, r24	; 23
			DPORT|=  (1<<DB7)|(1<<DB6)|(1<<DB5)|(1<<DB4);
 1b4:	88 b3       	in	r24, 0x18	; 24
 1b6:	80 6f       	ori	r24, 0xF0	; 240
 1b8:	88 bb       	out	0x18, r24	; 24
	HiPin();
}
static void Busy_flag(void)		    //Проверка флага занятости
{
	InPin();
	CPORT|=(1<<RW);	  //R/W=1 читаем из LCD
 1ba:	c1 9a       	sbi	0x18, 1	; 24
			}
	#else
			uint8_t i=1;
			while(i==1)
			{
				CPORT|=(1<<E);//Включили строб.
 1bc:	c0 9a       	sbi	0x18, 0	; 24
				asm("nop");
 1be:	00 00       	nop
				asm("nop");
 1c0:	00 00       	nop
		
				if (!(DPIN&(1<<DB7)))//Считали и проверили флаг занятости.
 1c2:	16 b3       	in	r17, 0x16	; 22
				{
					i=0;
				}
		
				CPORT&=~(1<<E);//Выключили строб.
 1c4:	c0 98       	cbi	0x18, 0	; 24
				asm("nop");
 1c6:	00 00       	nop
				asm("nop");
 1c8:	00 00       	nop
				Strob();
 1ca:	0e 94 cf 00 	call	0x19e	; 0x19e <Strob>
				asm("nop");
 1ce:	00 00       	nop
				asm("nop");
 1d0:	00 00       	nop
				asm("nop");
				asm("nop");						
			}
	#else
			uint8_t i=1;
			while(i==1)
 1d2:	17 fd       	sbrc	r17, 7
 1d4:	f3 cf       	rjmp	.-26     	; 0x1bc <Busy_flag+0x10>
				asm("nop");
		
			}
	#endif
	
	CPORT&=~(1<<RW);   //R/W=0 
 1d6:	c1 98       	cbi	0x18, 1	; 24
}
 1d8:	1f 91       	pop	r17
 1da:	08 95       	ret

000001dc <Send_byte>:
{
	Busy_flag();	//Проверим сперва флаг занятости, а свободен ли дисплей?
	Send_byte(i);
}
static void Send_byte(uint8_t i)	//Передача данных LCD, вызывается функциями Send_command и Send_data.
{
 1dc:	1f 93       	push	r17
 1de:	18 2f       	mov	r17, r24
	OutPin();
 1e0:	0e 94 c8 00 	call	0x190	; 0x190 <OutPin>
			
		    Strob();
			
	#else
			
			uint8_t higb = ((i&0b11110000)>>4);
 1e4:	81 2f       	mov	r24, r17
 1e6:	82 95       	swap	r24
 1e8:	8f 70       	andi	r24, 0x0F	; 15
			uint8_t lowb =  (i&0b00001111);
 1ea:	1f 70       	andi	r17, 0x0F	; 15
	
			if ((higb&1)==1)
 1ec:	80 fd       	sbrc	r24, 0
			{
				DPORT|=(1<<DB4);
 1ee:	c4 9a       	sbi	0x18, 4	; 24
			}
			higb=higb>>1;
 1f0:	86 95       	lsr	r24
			if ((higb&1)==1)
 1f2:	80 fd       	sbrc	r24, 0
			{
				DPORT|=(1<<DB5);
 1f4:	c5 9a       	sbi	0x18, 5	; 24
			}
			higb=higb>>1;
 1f6:	86 95       	lsr	r24
			if ((higb&1)==1)
 1f8:	80 fd       	sbrc	r24, 0
			{
				DPORT|=(1<<DB6);
 1fa:	c6 9a       	sbi	0x18, 6	; 24
			}
			higb=higb>>1;
 1fc:	86 95       	lsr	r24
			if ((higb&1)==1)
 1fe:	09 f0       	breq	.+2      	; 0x202 <Send_byte+0x26>
			{
				DPORT|=(1<<DB7);
 200:	c7 9a       	sbi	0x18, 7	; 24
			}
	
			Strob();
 202:	0e 94 cf 00 	call	0x19e	; 0x19e <Strob>
			OutPin();
 206:	0e 94 c8 00 	call	0x190	; 0x190 <OutPin>
	
			if ((lowb&1)==1)
 20a:	10 fd       	sbrc	r17, 0
			{
				DPORT|=(1<<DB4);
 20c:	c4 9a       	sbi	0x18, 4	; 24
			}
			lowb=lowb>>1;
 20e:	16 95       	lsr	r17
			if ((lowb&1)==1)
 210:	10 fd       	sbrc	r17, 0
			{
				DPORT|=(1<<DB5);
 212:	c5 9a       	sbi	0x18, 5	; 24
			}
			lowb=lowb>>1;
 214:	16 95       	lsr	r17
			if ((lowb&1)==1)
 216:	10 fd       	sbrc	r17, 0
			{
				DPORT|=(1<<DB6);
 218:	c6 9a       	sbi	0x18, 6	; 24
			}
			lowb=lowb>>1;
 21a:	16 95       	lsr	r17
			if ((lowb&1)==1)
 21c:	09 f0       	breq	.+2      	; 0x220 <Send_byte+0x44>
			{
				DPORT|=(1<<DB7);
 21e:	c7 9a       	sbi	0x18, 7	; 24
			}
	
			Strob();
 220:	0e 94 cf 00 	call	0x19e	; 0x19e <Strob>
{
	#ifdef  LCD_8BIT
			DDDR =0;
			DPORT=0;
	#else
			DDDR &=~((1<<DB7)|(1<<DB6)|(1<<DB5)|(1<<DB4));
 224:	87 b3       	in	r24, 0x17	; 23
 226:	8f 70       	andi	r24, 0x0F	; 15
 228:	87 bb       	out	0x17, r24	; 23
			DPORT&=~((1<<DB7)|(1<<DB6)|(1<<DB5)|(1<<DB4));
 22a:	88 b3       	in	r24, 0x18	; 24
 22c:	8f 70       	andi	r24, 0x0F	; 15
 22e:	88 bb       	out	0x18, r24	; 24
	
			Strob();
	#endif
	
	HiPin();
}
 230:	1f 91       	pop	r17
 232:	08 95       	ret

00000234 <LCDcommand>:
	LCDcommand(0b10);
}

//Системные функции, их не трогаем, они для работы дисплея.
static void LCDcommand(uint8_t i)	//Отправка команды, настройка дисплея.
{
 234:	df 93       	push	r29
 236:	cf 93       	push	r28
 238:	0f 92       	push	r0
 23a:	cd b7       	in	r28, 0x3d	; 61
 23c:	de b7       	in	r29, 0x3e	; 62
	Busy_flag();	//Проверим сперва флаг занятости, а свободен ли дисплей?
 23e:	89 83       	std	Y+1, r24	; 0x01
 240:	0e 94 d6 00 	call	0x1ac	; 0x1ac <Busy_flag>
	Send_byte(i);
 244:	89 81       	ldd	r24, Y+1	; 0x01
 246:	0e 94 ee 00 	call	0x1dc	; 0x1dc <Send_byte>
}
 24a:	0f 90       	pop	r0
 24c:	cf 91       	pop	r28
 24e:	df 91       	pop	r29
 250:	08 95       	ret

00000252 <LCDdata>:
};

//Пользовательские функции для LCD, ими пользуемся в программе.
#if 1
void LCDdata(uint8_t i)						//Отправка символа для отображения на дисплее.
{
 252:	df 93       	push	r29
 254:	cf 93       	push	r28
 256:	0f 92       	push	r0
 258:	cd b7       	in	r28, 0x3d	; 61
 25a:	de b7       	in	r29, 0x3e	; 62
	Busy_flag();	//Проверим сперва флаг занятости, а свободен ли дисплей?
 25c:	89 83       	std	Y+1, r24	; 0x01
 25e:	0e 94 d6 00 	call	0x1ac	; 0x1ac <Busy_flag>
	CPORT|=(1<<RS); //RS=1 посылаем данные в LCD
 262:	c2 9a       	sbi	0x18, 2	; 24
	CPORT&=~(1<<E);//Выключили строб.
}
static uint8_t lcd_rus(uint8_t c)
{

	if  (c > 191)
 264:	89 81       	ldd	r24, Y+1	; 0x01
 266:	80 3c       	cpi	r24, 0xC0	; 192
 268:	30 f0       	brcs	.+12     	; 0x276 <LCDdata+0x24>
	{
		c -=192;
 26a:	80 5c       	subi	r24, 0xC0	; 192
		c= pgm_read_byte(&convert_HD44780[c]);
 26c:	e8 2f       	mov	r30, r24
 26e:	f0 e0       	ldi	r31, 0x00	; 0
 270:	ec 5a       	subi	r30, 0xAC	; 172
 272:	ff 4f       	sbci	r31, 0xFF	; 255
 274:	84 91       	lpm	r24, Z+
#if 1
void LCDdata(uint8_t i)						//Отправка символа для отображения на дисплее.
{
	Busy_flag();	//Проверим сперва флаг занятости, а свободен ли дисплей?
	CPORT|=(1<<RS); //RS=1 посылаем данные в LCD
	Send_byte(lcd_rus(i));
 276:	0e 94 ee 00 	call	0x1dc	; 0x1dc <Send_byte>
	CPORT&=~(1<<RS);//RS=0
 27a:	c2 98       	cbi	0x18, 2	; 24
}
 27c:	0f 90       	pop	r0
 27e:	cf 91       	pop	r28
 280:	df 91       	pop	r29
 282:	08 95       	ret

00000284 <LCDGotoXY>:
}
void LCDGotoXY(uint8_t x,uint8_t y)			//Устанавливаем курсор в X, Y позицию
{
	 uint8_t Address;
	
	switch(y)
 284:	61 30       	cpi	r22, 0x01	; 1
 286:	09 f4       	brne	.+2      	; 0x28a <LCDGotoXY+0x6>
	{
		case 0: Address = LINE0+x; 
				break;
		case 1: Address = LINE1+x; 
 288:	80 5c       	subi	r24, 0xC0	; 192
				break;
		default: Address = LINE0+x;
	}
	
	LCDcommand(1<<7 | Address);
 28a:	80 68       	ori	r24, 0x80	; 128
 28c:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 290:	08 95       	ret

00000292 <LCDdataXY>:
	CPORT|=(1<<RS); //RS=1 посылаем данные в LCD
	Send_byte(lcd_rus(i));
	CPORT&=~(1<<RS);//RS=0
}
void LCDdataXY (uint8_t a, uint8_t b,uint8_t c)	//Вывести 1 символ на дисплей в X, Y позицию .
{
 292:	1f 93       	push	r17
 294:	18 2f       	mov	r17, r24
 296:	86 2f       	mov	r24, r22
	LCDGotoXY(b,c);
 298:	64 2f       	mov	r22, r20
 29a:	0e 94 42 01 	call	0x284	; 0x284 <LCDGotoXY>
	LCDdata(a);
 29e:	81 2f       	mov	r24, r17
 2a0:	0e 94 29 01 	call	0x252	; 0x252 <LCDdata>
}
 2a4:	1f 91       	pop	r17
 2a6:	08 95       	ret

000002a8 <LCDstringXY>:
	}
	
	LCDcommand(1<<7 | Address);
}
void LCDstringXY(char *i,uint8_t x,uint8_t y) //Вывести строку на дисплей X,Y
{
 2a8:	ef 92       	push	r14
 2aa:	ff 92       	push	r15
 2ac:	0f 93       	push	r16
 2ae:	1f 93       	push	r17
 2b0:	df 93       	push	r29
 2b2:	cf 93       	push	r28
 2b4:	0f 92       	push	r0
 2b6:	cd b7       	in	r28, 0x3d	; 61
 2b8:	de b7       	in	r29, 0x3e	; 62
 2ba:	18 2f       	mov	r17, r24
 2bc:	86 2f       	mov	r24, r22
	LCDGotoXY(x,y);
 2be:	64 2f       	mov	r22, r20
 2c0:	99 83       	std	Y+1, r25	; 0x01
 2c2:	0e 94 42 01 	call	0x284	; 0x284 <LCDGotoXY>
 2c6:	99 81       	ldd	r25, Y+1	; 0x01
 2c8:	61 2f       	mov	r22, r17
 2ca:	79 2f       	mov	r23, r25
 2cc:	8b 01       	movw	r16, r22
	while( *i )
 2ce:	02 c0       	rjmp	.+4      	; 0x2d4 <LCDstringXY+0x2c>
	{
		LCDdata(*i++ );
 2d0:	0e 94 29 01 	call	0x252	; 0x252 <LCDdata>
	LCDcommand(1<<7 | Address);
}
void LCDstringXY(char *i,uint8_t x,uint8_t y) //Вывести строку на дисплей X,Y
{
	LCDGotoXY(x,y);
	while( *i )
 2d4:	f8 01       	movw	r30, r16
 2d6:	81 91       	ld	r24, Z+
 2d8:	8f 01       	movw	r16, r30
 2da:	88 23       	and	r24, r24
 2dc:	c9 f7       	brne	.-14     	; 0x2d0 <LCDstringXY+0x28>
	{
		LCDdata(*i++ );
	}
}
 2de:	0f 90       	pop	r0
 2e0:	cf 91       	pop	r28
 2e2:	df 91       	pop	r29
 2e4:	1f 91       	pop	r17
 2e6:	0f 91       	pop	r16
 2e8:	ff 90       	pop	r15
 2ea:	ef 90       	pop	r14
 2ec:	08 95       	ret

000002ee <LCDsendString>:
void LCDsendString(char *s)//Вывести строку на дисплей.
{
 2ee:	ef 92       	push	r14
 2f0:	ff 92       	push	r15
 2f2:	cf 93       	push	r28
 2f4:	df 93       	push	r29
 2f6:	e8 2e       	mov	r14, r24
 2f8:	e7 01       	movw	r28, r14
 2fa:	7e 01       	movw	r14, r28
 2fc:	f9 2e       	mov	r15, r25
 2fe:	e7 01       	movw	r28, r14
	while( *s )
 300:	02 c0       	rjmp	.+4      	; 0x306 <LCDsendString+0x18>
	{
		LCDdata(*s++ );
 302:	0e 94 29 01 	call	0x252	; 0x252 <LCDdata>
		LCDdata(*i++ );
	}
}
void LCDsendString(char *s)//Вывести строку на дисплей.
{
	while( *s )
 306:	89 91       	ld	r24, Y+
 308:	88 23       	and	r24, r24
 30a:	d9 f7       	brne	.-10     	; 0x302 <LCDsendString+0x14>
	{
		LCDdata(*s++ );
	}
	
}
 30c:	df 91       	pop	r29
 30e:	cf 91       	pop	r28
 310:	ff 90       	pop	r15
 312:	ef 90       	pop	r14
 314:	08 95       	ret

00000316 <LCDstring_of_sramXY>:
void LCDstring_of_sramXY(uint8_t* data,uint8_t x, uint8_t y)
{
 316:	1f 93       	push	r17
 318:	cf 93       	push	r28
 31a:	df 93       	push	r29
 31c:	ec 01       	movw	r28, r24
 31e:	86 2f       	mov	r24, r22
	LCDGotoXY(x,y);
 320:	64 2f       	mov	r22, r20
 322:	0e 94 42 01 	call	0x284	; 0x284 <LCDGotoXY>
	if (!data)
 326:	20 97       	sbiw	r28, 0x00	; 0
 328:	59 f0       	breq	.+22     	; 0x340 <LCDstring_of_sramXY+0x2a>
 32a:	10 e0       	ldi	r17, 0x00	; 0
 32c:	03 c0       	rjmp	.+6      	; 0x334 <LCDstring_of_sramXY+0x1e>
	}
	
	uint8_t i=0;
	while(data[i] != '\0')
	{
		LCDdata(data[i]);
 32e:	0e 94 29 01 	call	0x252	; 0x252 <LCDdata>
		i++;
 332:	1f 5f       	subi	r17, 0xFF	; 255
	{
		return;
	}
	
	uint8_t i=0;
	while(data[i] != '\0')
 334:	fe 01       	movw	r30, r28
 336:	e1 0f       	add	r30, r17
 338:	f1 1d       	adc	r31, r1
 33a:	80 81       	ld	r24, Z
 33c:	88 23       	and	r24, r24
 33e:	b9 f7       	brne	.-18     	; 0x32e <LCDstring_of_sramXY+0x18>
	{
		LCDdata(data[i]);
		i++;
	}
}
 340:	df 91       	pop	r29
 342:	cf 91       	pop	r28
 344:	1f 91       	pop	r17
 346:	08 95       	ret

00000348 <LCDstring_of_flashXY>:
void LCDstring_of_flashXY(const uint8_t *FlashLoc,uint8_t x,uint8_t y)
{
 348:	1f 93       	push	r17
 34a:	cf 93       	push	r28
 34c:	df 93       	push	r29
 34e:	ec 01       	movw	r28, r24
 350:	86 2f       	mov	r24, r22
	uint8_t i;
	LCDGotoXY(x,y);
 352:	64 2f       	mov	r22, r20
 354:	0e 94 42 01 	call	0x284	; 0x284 <LCDGotoXY>
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
 358:	10 e0       	ldi	r17, 0x00	; 0
 35a:	03 c0       	rjmp	.+6      	; 0x362 <LCDstring_of_flashXY+0x1a>
	{
		LCDdata((uint8_t)pgm_read_byte(&FlashLoc[i]));
 35c:	0e 94 29 01 	call	0x252	; 0x252 <LCDdata>
}
void LCDstring_of_flashXY(const uint8_t *FlashLoc,uint8_t x,uint8_t y)
{
	uint8_t i;
	LCDGotoXY(x,y);
	for(i=0;(uint8_t)pgm_read_byte(&FlashLoc[i]);i++)
 360:	1f 5f       	subi	r17, 0xFF	; 255
 362:	fe 01       	movw	r30, r28
 364:	e1 0f       	add	r30, r17
 366:	f1 1d       	adc	r31, r1
 368:	84 91       	lpm	r24, Z+
 36a:	88 23       	and	r24, r24
 36c:	b9 f7       	brne	.-18     	; 0x35c <LCDstring_of_flashXY+0x14>
	{
		LCDdata((uint8_t)pgm_read_byte(&FlashLoc[i]));
	}
}
 36e:	df 91       	pop	r29
 370:	cf 91       	pop	r28
 372:	1f 91       	pop	r17
 374:	08 95       	ret

00000376 <LCDinit>:
void LCDinit(void)							//Инициализируем дисплей
{
 376:	1f 93       	push	r17
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 378:	8f ef       	ldi	r24, 0xFF	; 255
 37a:	90 e7       	ldi	r25, 0x70	; 112
 37c:	a2 e0       	ldi	r26, 0x02	; 2
 37e:	81 50       	subi	r24, 0x01	; 1
 380:	90 40       	sbci	r25, 0x00	; 0
 382:	a0 40       	sbci	r26, 0x00	; 0
 384:	e1 f7       	brne	.-8      	; 0x37e <LCDinit+0x8>
 386:	00 c0       	rjmp	.+0      	; 0x388 <LCDinit+0x12>
 388:	00 00       	nop
	//Перед инициализацией LCD, надо в init задержку в 100 мсек сделать, чтоб питание устаканилось. 
	_delay_ms(100);
	CDDR |=  (1<<RS)|(1<<E)|(1<<RW);   //Настройка портов 
 38a:	87 b3       	in	r24, 0x17	; 23
 38c:	87 60       	ori	r24, 0x07	; 7
 38e:	87 bb       	out	0x17, r24	; 23
	CPORT&=~((1<<RS)|(1<<E)|(1<<RW));  //Настройка портов 
 390:	88 b3       	in	r24, 0x18	; 24
 392:	88 7f       	andi	r24, 0xF8	; 248
 394:	88 bb       	out	0x18, r24	; 24
	OutPin();						   //Настройка портов
 396:	0e 94 c8 00 	call	0x190	; 0x190 <OutPin>
 39a:	13 e0       	ldi	r17, 0x03	; 3
	while (i!=3)
	{
		#ifdef  LCD_8BIT       //отправка символа 0x30.
		        DPORT|=(0<<DB7)|(0<<DB6)|(1<<DB5)|(1<<DB4)|(0<<DB3)|(0<<DB2)|(0<<DB1)|(0<<DB0);
		#else
				DPORT|=(0<<DB7)|(0<<DB6)|(1<<DB5)|(1<<DB4);
 39c:	88 b3       	in	r24, 0x18	; 24
 39e:	80 63       	ori	r24, 0x30	; 48
 3a0:	88 bb       	out	0x18, r24	; 24
		#endif
		
		Strob();
 3a2:	0e 94 cf 00 	call	0x19e	; 0x19e <Strob>
 3a6:	af e0       	ldi	r26, 0x0F	; 15
 3a8:	b7 e2       	ldi	r27, 0x27	; 39
 3aa:	11 97       	sbiw	r26, 0x01	; 1
 3ac:	f1 f7       	brne	.-4      	; 0x3aa <LCDinit+0x34>
 3ae:	00 c0       	rjmp	.+0      	; 0x3b0 <LCDinit+0x3a>
 3b0:	00 00       	nop
 3b2:	11 50       	subi	r17, 0x01	; 1
	CDDR |=  (1<<RS)|(1<<E)|(1<<RW);   //Настройка портов 
	CPORT&=~((1<<RS)|(1<<E)|(1<<RW));  //Настройка портов 
	OutPin();						   //Настройка портов
	
	uint8_t i=0;
	while (i!=3)
 3b4:	99 f7       	brne	.-26     	; 0x39c <LCDinit+0x26>
	//Разминочный этап закончен, далее переходим к основным упражнениям.
	
	#ifdef  LCD_8BIT
			LCDcommand(0b00111000);//8ми битный интерфейс, две строки, 5x8 точек.
	#else   //Первый раз отправляем только пол старшей тетрады
			Busy_flag();
 3b6:	0e 94 d6 00 	call	0x1ac	; 0x1ac <Busy_flag>
			OutPin();
 3ba:	0e 94 c8 00 	call	0x190	; 0x190 <OutPin>
			DPORT|=(0<<DB7)|(0<<DB6)|(1<<DB5)|(0<<DB4);//4х битный интерфейс 
 3be:	c5 9a       	sbi	0x18, 5	; 24
			Strob();
 3c0:	0e 94 cf 00 	call	0x19e	; 0x19e <Strob>
			LCDcommand(0b00101000);//Две строки, 5x8 точек.
 3c4:	88 e2       	ldi	r24, 0x28	; 40
 3c6:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
	#endif
	
	LCDcommand(0b1100);  //Включаем дисплей + без отображения курсоров.
 3ca:	8c e0       	ldi	r24, 0x0C	; 12
 3cc:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
	LCDcommand(0b110);   //Счетчик адреса всегда будет смещаться на n+1
 3d0:	86 e0       	ldi	r24, 0x06	; 6
 3d2:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
	LCDcommand(0b10);    //курсор в позицию 0,0 + сброс всех сдвигов
 3d6:	82 e0       	ldi	r24, 0x02	; 2
 3d8:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
	LCDcommand(0b1);     //очистка дисплея 
 3dc:	81 e0       	ldi	r24, 0x01	; 1
 3de:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
	//Основные упражнения закончены. Переходим к релаксации.
}
 3e2:	1f 91       	pop	r17
 3e4:	08 95       	ret

000003e6 <LCDblank>:
void LCDblank(void)			//Сделать невидимой инфо на дисплее
{
	LCDcommand(0b1000);
 3e6:	88 e0       	ldi	r24, 0x08	; 8
 3e8:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 3ec:	08 95       	ret

000003ee <LCDnblank>:
void LCDnblank(void)		//Сделать видимой инфо на дисплее + отключить видимые курсоры.
{
	LCDcommand(0b1100);
 3ee:	8c e0       	ldi	r24, 0x0C	; 12
 3f0:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 3f4:	08 95       	ret

000003f6 <LCDclear>:
void LCDclear(void)			//Очистка дисплея + курсор на позицию 0,0
{
	LCDcommand(0b1);
 3f6:	81 e0       	ldi	r24, 0x01	; 1
 3f8:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 3fc:	08 95       	ret

000003fe <LCDcursor_bl>:
void LCDcursor_bl(void)		//Включить мигающий курсор
{
	LCDcommand(0b1101);
 3fe:	8d e0       	ldi	r24, 0x0D	; 13
 400:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 404:	08 95       	ret

00000406 <LCDcursor_on>:
void LCDcursor_on(void)		//Включить подчеркивающий курсор
{
	LCDcommand(0b1110);
 406:	8e e0       	ldi	r24, 0x0E	; 14
 408:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 40c:	08 95       	ret

0000040e <LCDcursor_vi>:
void LCDcursor_vi(void)		//Включить оба курсора
{
	LCDcommand(0b1111);
 40e:	8f e0       	ldi	r24, 0x0F	; 15
 410:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 414:	08 95       	ret

00000416 <LCDcursorOFF>:
void LCDcursorOFF(void)		//Выключить курсор
{
	LCDcommand(0b1100);
 416:	8c e0       	ldi	r24, 0x0C	; 12
 418:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 41c:	08 95       	ret

0000041e <LCDacr>:
void LCDacr(void)			//Cчетчик адреса всегда будет смещаться на n+1
{
	LCDcommand(0b110);
 41e:	86 e0       	ldi	r24, 0x06	; 6
 420:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 424:	08 95       	ret

00000426 <LCDacl>:
void LCDacl(void)			//Cчетчик адреса всегда будет смещаться на n-1
{
	LCDcommand(0b100);
 426:	84 e0       	ldi	r24, 0x04	; 4
 428:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 42c:	08 95       	ret

0000042e <LCDcursorl>:
void LCDcursorl(void)		//Сместить курсор влево на 1
{
	LCDcommand(0b10000);
 42e:	80 e1       	ldi	r24, 0x10	; 16
 430:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 434:	08 95       	ret

00000436 <LCDcursorr>:
void LCDcursorr(void)		//Сместить курсор вправо на 1
{
	LCDcommand(0b10100);
 436:	84 e1       	ldi	r24, 0x14	; 20
 438:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 43c:	08 95       	ret

0000043e <LCDcursorln>:
void LCDcursorln(uint8_t n)	//Сместить курсор влево на n символов
{
 43e:	0f 93       	push	r16
 440:	1f 93       	push	r17
 442:	08 2f       	mov	r16, r24
	for (uint8_t i=0;i<n;i++)
 444:	10 e0       	ldi	r17, 0x00	; 0
 446:	04 c0       	rjmp	.+8      	; 0x450 <LCDcursorln+0x12>
	{
		LCDcommand(0b10000);
 448:	80 e1       	ldi	r24, 0x10	; 16
 44a:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
{
	LCDcommand(0b10100);
}
void LCDcursorln(uint8_t n)	//Сместить курсор влево на n символов
{
	for (uint8_t i=0;i<n;i++)
 44e:	1f 5f       	subi	r17, 0xFF	; 255
 450:	10 17       	cp	r17, r16
 452:	d0 f3       	brcs	.-12     	; 0x448 <LCDcursorln+0xa>
	{
		LCDcommand(0b10000);
	}
}
 454:	1f 91       	pop	r17
 456:	0f 91       	pop	r16
 458:	08 95       	ret

0000045a <LCDcursorrn>:
void LCDcursorrn(uint8_t n)	//Сместить курсор вправо на n символов
{
 45a:	0f 93       	push	r16
 45c:	1f 93       	push	r17
 45e:	08 2f       	mov	r16, r24
	for (uint8_t i=0;i<n;i++)
 460:	10 e0       	ldi	r17, 0x00	; 0
 462:	04 c0       	rjmp	.+8      	; 0x46c <__stack+0xd>
	{
		LCDcommand(0b10100);
 464:	84 e1       	ldi	r24, 0x14	; 20
 466:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
		LCDcommand(0b10000);
	}
}
void LCDcursorrn(uint8_t n)	//Сместить курсор вправо на n символов
{
	for (uint8_t i=0;i<n;i++)
 46a:	1f 5f       	subi	r17, 0xFF	; 255
 46c:	10 17       	cp	r17, r16
 46e:	d0 f3       	brcs	.-12     	; 0x464 <__stack+0x5>
	{
		LCDcommand(0b10100);
	}
}
 470:	1f 91       	pop	r17
 472:	0f 91       	pop	r16
 474:	08 95       	ret

00000476 <LCDscreenl>:
void LCDscreenl(void)		//Сместить экран влево на 1
{
	LCDcommand(0b11000);
 476:	88 e1       	ldi	r24, 0x18	; 24
 478:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 47c:	08 95       	ret

0000047e <LCDscreenr>:
void LCDscreenr(void)		//Сместить экран вправо на 1
{
	LCDcommand(0b11100);
 47e:	8c e1       	ldi	r24, 0x1C	; 28
 480:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 484:	08 95       	ret

00000486 <LCDscreenln>:
void LCDscreenln(uint8_t n)	//Сместить экран влево на n символов
{
 486:	0f 93       	push	r16
 488:	1f 93       	push	r17
 48a:	08 2f       	mov	r16, r24
	for (uint8_t i=0;i<n;i++)
 48c:	10 e0       	ldi	r17, 0x00	; 0
 48e:	04 c0       	rjmp	.+8      	; 0x498 <LCDscreenln+0x12>
	{
		LCDcommand(0b11000);
 490:	88 e1       	ldi	r24, 0x18	; 24
 492:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
{
	LCDcommand(0b11100);
}
void LCDscreenln(uint8_t n)	//Сместить экран влево на n символов
{
	for (uint8_t i=0;i<n;i++)
 496:	1f 5f       	subi	r17, 0xFF	; 255
 498:	10 17       	cp	r17, r16
 49a:	d0 f3       	brcs	.-12     	; 0x490 <LCDscreenln+0xa>
	{
		LCDcommand(0b11000);
	}
}
 49c:	1f 91       	pop	r17
 49e:	0f 91       	pop	r16
 4a0:	08 95       	ret

000004a2 <LCDscreenrn>:
void LCDscreenrn(uint8_t n)	//Сместить экран вправо на n символов
{
 4a2:	0f 93       	push	r16
 4a4:	1f 93       	push	r17
 4a6:	08 2f       	mov	r16, r24
	for (uint8_t i=0;i<n;i++)
 4a8:	10 e0       	ldi	r17, 0x00	; 0
 4aa:	04 c0       	rjmp	.+8      	; 0x4b4 <LCDscreenrn+0x12>
	{
		LCDcommand(0b11100);
 4ac:	8c e1       	ldi	r24, 0x1C	; 28
 4ae:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
		LCDcommand(0b11000);
	}
}
void LCDscreenrn(uint8_t n)	//Сместить экран вправо на n символов
{
	for (uint8_t i=0;i<n;i++)
 4b2:	1f 5f       	subi	r17, 0xFF	; 255
 4b4:	10 17       	cp	r17, r16
 4b6:	d0 f3       	brcs	.-12     	; 0x4ac <LCDscreenrn+0xa>
	{
		LCDcommand(0b11100);
	}
}
 4b8:	1f 91       	pop	r17
 4ba:	0f 91       	pop	r16
 4bc:	08 95       	ret

000004be <LCDscreenL>:
void LCDscreenL(void)		//С каждым новым символом экран будет смещаться влево
{
	LCDcommand(0b101);
 4be:	85 e0       	ldi	r24, 0x05	; 5
 4c0:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 4c4:	08 95       	ret

000004c6 <LCDscreenR>:
void LCDscreenR(void)		//С каждым новым символом экран будет смещаться вправо
{
	LCDcommand(0b111);
 4c6:	87 e0       	ldi	r24, 0x07	; 7
 4c8:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 4cc:	08 95       	ret

000004ce <LCDresshift>:
void LCDresshift(void)      //Установить курсор в позицию 0,0 + сброс всех сдвигов, изображение остается
{
	LCDcommand(0b10);
 4ce:	82 e0       	ldi	r24, 0x02	; 2
 4d0:	0e 94 1a 01 	call	0x234	; 0x234 <LCDcommand>
}
 4d4:	08 95       	ret

000004d6 <BCD_GetPointerBuf>:
	#ifdef BCD_USE_BUF
	return (uint8_t*)buf;
	#else
	return (uint8_t *)0;
	#endif
}
 4d6:	81 e7       	ldi	r24, 0x71	; 113
 4d8:	90 e0       	ldi	r25, 0x00	; 0
 4da:	08 95       	ret

000004dc <BCD_1>:

void BCD_1(uint8_t value)
{
	BCD_InitIndexBuf(i);
	
	value += BCD_SYMBOL;
 4dc:	80 5d       	subi	r24, 0xD0	; 208
	
	BCD_SaveDataInBuf(value, buf, i);
 4de:	80 93 71 00 	sts	0x0071, r24
 4e2:	81 e0       	ldi	r24, 0x01	; 1
 4e4:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 4e8:	10 92 72 00 	sts	0x0072, r1
	BCD_SendData(value);
}
 4ec:	08 95       	ret

000004ee <BCD_2>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;
	
	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 10);
 4ee:	90 e0       	ldi	r25, 0x00	; 0
 4f0:	02 c0       	rjmp	.+4      	; 0x4f6 <BCD_2+0x8>
 4f2:	9f 5f       	subi	r25, 0xFF	; 255
 4f4:	8a 50       	subi	r24, 0x0A	; 10
 4f6:	8a 30       	cpi	r24, 0x0A	; 10
 4f8:	e0 f7       	brcc	.-8      	; 0x4f2 <BCD_2+0x4>
 4fa:	99 23       	and	r25, r25
 4fc:	11 f0       	breq	.+4      	; 0x502 <BCD_2+0x14>
 4fe:	90 5d       	subi	r25, 0xD0	; 208
 500:	01 c0       	rjmp	.+2      	; 0x504 <BCD_2+0x16>
 502:	90 e3       	ldi	r25, 0x30	; 48
 504:	90 93 71 00 	sts	0x0071, r25

	value += BCD_SYMBOL;
 508:	80 5d       	subi	r24, 0xD0	; 208
	BCD_SaveDataInBuf(value, buf, i);
 50a:	80 93 72 00 	sts	0x0072, r24
 50e:	82 e0       	ldi	r24, 0x02	; 2
 510:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 514:	10 92 73 00 	sts	0x0073, r1
	BCD_SendData(value);
}
 518:	08 95       	ret

0000051a <BCD_3>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;

	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 100);
 51a:	90 e0       	ldi	r25, 0x00	; 0
 51c:	02 c0       	rjmp	.+4      	; 0x522 <BCD_3+0x8>
 51e:	9f 5f       	subi	r25, 0xFF	; 255
 520:	84 56       	subi	r24, 0x64	; 100
 522:	84 36       	cpi	r24, 0x64	; 100
 524:	e0 f7       	brcc	.-8      	; 0x51e <BCD_3+0x4>
 526:	99 23       	and	r25, r25
 528:	11 f0       	breq	.+4      	; 0x52e <BCD_3+0x14>
 52a:	90 5d       	subi	r25, 0xD0	; 208
 52c:	01 c0       	rjmp	.+2      	; 0x530 <BCD_3+0x16>
 52e:	90 e3       	ldi	r25, 0x30	; 48
 530:	90 93 71 00 	sts	0x0071, r25
	BCD_Calc(digit, value, flag, buf, i, 10);
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	02 c0       	rjmp	.+4      	; 0x53c <BCD_3+0x22>
 538:	9f 5f       	subi	r25, 0xFF	; 255
 53a:	8a 50       	subi	r24, 0x0A	; 10
 53c:	8a 30       	cpi	r24, 0x0A	; 10
 53e:	e0 f7       	brcc	.-8      	; 0x538 <BCD_3+0x1e>
 540:	99 23       	and	r25, r25
 542:	11 f0       	breq	.+4      	; 0x548 <BCD_3+0x2e>
 544:	90 5d       	subi	r25, 0xD0	; 208
 546:	01 c0       	rjmp	.+2      	; 0x54a <BCD_3+0x30>
 548:	90 e3       	ldi	r25, 0x30	; 48
 54a:	90 93 72 00 	sts	0x0072, r25
	
	value += BCD_SYMBOL;
 54e:	80 5d       	subi	r24, 0xD0	; 208
	BCD_SaveDataInBuf(value, buf, i);
 550:	80 93 73 00 	sts	0x0073, r24
 554:	83 e0       	ldi	r24, 0x03	; 3
 556:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 55a:	10 92 74 00 	sts	0x0074, r1
}
 55e:	08 95       	ret

00000560 <BCD_3Int>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;

	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 100);
 560:	20 e0       	ldi	r18, 0x00	; 0
 562:	03 c0       	rjmp	.+6      	; 0x56a <BCD_3Int+0xa>
 564:	2f 5f       	subi	r18, 0xFF	; 255
 566:	84 56       	subi	r24, 0x64	; 100
 568:	90 40       	sbci	r25, 0x00	; 0
 56a:	84 36       	cpi	r24, 0x64	; 100
 56c:	91 05       	cpc	r25, r1
 56e:	d0 f7       	brcc	.-12     	; 0x564 <BCD_3Int+0x4>
 570:	22 23       	and	r18, r18
 572:	11 f0       	breq	.+4      	; 0x578 <BCD_3Int+0x18>
 574:	20 5d       	subi	r18, 0xD0	; 208
 576:	01 c0       	rjmp	.+2      	; 0x57a <BCD_3Int+0x1a>
 578:	20 e3       	ldi	r18, 0x30	; 48
 57a:	20 93 71 00 	sts	0x0071, r18
	BCD_Calc(digit, value, flag, buf, i, 10);
 57e:	20 e0       	ldi	r18, 0x00	; 0
 580:	02 c0       	rjmp	.+4      	; 0x586 <BCD_3Int+0x26>
 582:	2f 5f       	subi	r18, 0xFF	; 255
 584:	0a 97       	sbiw	r24, 0x0a	; 10
 586:	8a 30       	cpi	r24, 0x0A	; 10
 588:	91 05       	cpc	r25, r1
 58a:	d8 f7       	brcc	.-10     	; 0x582 <BCD_3Int+0x22>
 58c:	22 23       	and	r18, r18
 58e:	11 f0       	breq	.+4      	; 0x594 <BCD_3Int+0x34>
 590:	20 5d       	subi	r18, 0xD0	; 208
 592:	01 c0       	rjmp	.+2      	; 0x596 <BCD_3Int+0x36>
 594:	20 e3       	ldi	r18, 0x30	; 48
 596:	20 93 72 00 	sts	0x0072, r18
	
	value += BCD_SYMBOL;
 59a:	c0 96       	adiw	r24, 0x30	; 48
	BCD_SaveDataInBuf(value, buf, i);
 59c:	80 93 73 00 	sts	0x0073, r24
 5a0:	83 e0       	ldi	r24, 0x03	; 3
 5a2:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 5a6:	10 92 74 00 	sts	0x0074, r1
	BCD_SendData(value);
}
 5aa:	08 95       	ret

000005ac <BCD_4Int>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;

	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 1000);
 5ac:	20 e0       	ldi	r18, 0x00	; 0
 5ae:	03 c0       	rjmp	.+6      	; 0x5b6 <BCD_4Int+0xa>
 5b0:	2f 5f       	subi	r18, 0xFF	; 255
 5b2:	88 5e       	subi	r24, 0xE8	; 232
 5b4:	93 40       	sbci	r25, 0x03	; 3
 5b6:	33 e0       	ldi	r19, 0x03	; 3
 5b8:	88 3e       	cpi	r24, 0xE8	; 232
 5ba:	93 07       	cpc	r25, r19
 5bc:	c8 f7       	brcc	.-14     	; 0x5b0 <BCD_4Int+0x4>
 5be:	22 23       	and	r18, r18
 5c0:	11 f0       	breq	.+4      	; 0x5c6 <BCD_4Int+0x1a>
 5c2:	20 5d       	subi	r18, 0xD0	; 208
 5c4:	01 c0       	rjmp	.+2      	; 0x5c8 <BCD_4Int+0x1c>
 5c6:	20 e3       	ldi	r18, 0x30	; 48
 5c8:	20 93 71 00 	sts	0x0071, r18
	BCD_Calc(digit, value, flag, buf, i, 100);
 5cc:	20 e0       	ldi	r18, 0x00	; 0
 5ce:	03 c0       	rjmp	.+6      	; 0x5d6 <BCD_4Int+0x2a>
 5d0:	2f 5f       	subi	r18, 0xFF	; 255
 5d2:	84 56       	subi	r24, 0x64	; 100
 5d4:	90 40       	sbci	r25, 0x00	; 0
 5d6:	84 36       	cpi	r24, 0x64	; 100
 5d8:	91 05       	cpc	r25, r1
 5da:	d0 f7       	brcc	.-12     	; 0x5d0 <BCD_4Int+0x24>
 5dc:	22 23       	and	r18, r18
 5de:	11 f0       	breq	.+4      	; 0x5e4 <BCD_4Int+0x38>
 5e0:	20 5d       	subi	r18, 0xD0	; 208
 5e2:	01 c0       	rjmp	.+2      	; 0x5e6 <BCD_4Int+0x3a>
 5e4:	20 e3       	ldi	r18, 0x30	; 48
 5e6:	20 93 72 00 	sts	0x0072, r18
	BCD_Calc(digit, value, flag, buf, i, 10);
 5ea:	20 e0       	ldi	r18, 0x00	; 0
 5ec:	02 c0       	rjmp	.+4      	; 0x5f2 <BCD_4Int+0x46>
 5ee:	2f 5f       	subi	r18, 0xFF	; 255
 5f0:	0a 97       	sbiw	r24, 0x0a	; 10
 5f2:	8a 30       	cpi	r24, 0x0A	; 10
 5f4:	91 05       	cpc	r25, r1
 5f6:	d8 f7       	brcc	.-10     	; 0x5ee <BCD_4Int+0x42>
 5f8:	22 23       	and	r18, r18
 5fa:	11 f0       	breq	.+4      	; 0x600 <BCD_4Int+0x54>
 5fc:	20 5d       	subi	r18, 0xD0	; 208
 5fe:	01 c0       	rjmp	.+2      	; 0x602 <BCD_4Int+0x56>
 600:	20 e3       	ldi	r18, 0x30	; 48
 602:	20 93 73 00 	sts	0x0073, r18
	
	value += BCD_SYMBOL;
 606:	c0 96       	adiw	r24, 0x30	; 48
	BCD_SaveDataInBuf(value, buf, i);
 608:	80 93 74 00 	sts	0x0074, r24
 60c:	84 e0       	ldi	r24, 0x04	; 4
 60e:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 612:	10 92 75 00 	sts	0x0075, r1
	BCD_SendData(value);
}
 616:	08 95       	ret

00000618 <BCD_5Int>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;

	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 10000);
 618:	20 e0       	ldi	r18, 0x00	; 0
 61a:	03 c0       	rjmp	.+6      	; 0x622 <BCD_5Int+0xa>
 61c:	2f 5f       	subi	r18, 0xFF	; 255
 61e:	80 51       	subi	r24, 0x10	; 16
 620:	97 42       	sbci	r25, 0x27	; 39
 622:	37 e2       	ldi	r19, 0x27	; 39
 624:	80 31       	cpi	r24, 0x10	; 16
 626:	93 07       	cpc	r25, r19
 628:	c8 f7       	brcc	.-14     	; 0x61c <BCD_5Int+0x4>
 62a:	22 23       	and	r18, r18
 62c:	11 f0       	breq	.+4      	; 0x632 <BCD_5Int+0x1a>
 62e:	20 5d       	subi	r18, 0xD0	; 208
 630:	01 c0       	rjmp	.+2      	; 0x634 <BCD_5Int+0x1c>
 632:	20 e3       	ldi	r18, 0x30	; 48
 634:	20 93 71 00 	sts	0x0071, r18
	BCD_Calc(digit, value, flag, buf, i, 1000);
 638:	20 e0       	ldi	r18, 0x00	; 0
 63a:	03 c0       	rjmp	.+6      	; 0x642 <BCD_5Int+0x2a>
 63c:	2f 5f       	subi	r18, 0xFF	; 255
 63e:	88 5e       	subi	r24, 0xE8	; 232
 640:	93 40       	sbci	r25, 0x03	; 3
 642:	33 e0       	ldi	r19, 0x03	; 3
 644:	88 3e       	cpi	r24, 0xE8	; 232
 646:	93 07       	cpc	r25, r19
 648:	c8 f7       	brcc	.-14     	; 0x63c <BCD_5Int+0x24>
 64a:	22 23       	and	r18, r18
 64c:	11 f0       	breq	.+4      	; 0x652 <BCD_5Int+0x3a>
 64e:	20 5d       	subi	r18, 0xD0	; 208
 650:	01 c0       	rjmp	.+2      	; 0x654 <BCD_5Int+0x3c>
 652:	20 e3       	ldi	r18, 0x30	; 48
 654:	20 93 72 00 	sts	0x0072, r18
	BCD_Calc(digit, value, flag, buf, i, 100);
 658:	20 e0       	ldi	r18, 0x00	; 0
 65a:	03 c0       	rjmp	.+6      	; 0x662 <BCD_5Int+0x4a>
 65c:	2f 5f       	subi	r18, 0xFF	; 255
 65e:	84 56       	subi	r24, 0x64	; 100
 660:	90 40       	sbci	r25, 0x00	; 0
 662:	84 36       	cpi	r24, 0x64	; 100
 664:	91 05       	cpc	r25, r1
 666:	d0 f7       	brcc	.-12     	; 0x65c <BCD_5Int+0x44>
 668:	22 23       	and	r18, r18
 66a:	11 f0       	breq	.+4      	; 0x670 <BCD_5Int+0x58>
 66c:	20 5d       	subi	r18, 0xD0	; 208
 66e:	01 c0       	rjmp	.+2      	; 0x672 <BCD_5Int+0x5a>
 670:	20 e3       	ldi	r18, 0x30	; 48
 672:	20 93 73 00 	sts	0x0073, r18
	BCD_Calc(digit, value, flag, buf, i, 10);
 676:	20 e0       	ldi	r18, 0x00	; 0
 678:	02 c0       	rjmp	.+4      	; 0x67e <BCD_5Int+0x66>
 67a:	2f 5f       	subi	r18, 0xFF	; 255
 67c:	0a 97       	sbiw	r24, 0x0a	; 10
 67e:	8a 30       	cpi	r24, 0x0A	; 10
 680:	91 05       	cpc	r25, r1
 682:	d8 f7       	brcc	.-10     	; 0x67a <BCD_5Int+0x62>
 684:	22 23       	and	r18, r18
 686:	11 f0       	breq	.+4      	; 0x68c <BCD_5Int+0x74>
 688:	20 5d       	subi	r18, 0xD0	; 208
 68a:	01 c0       	rjmp	.+2      	; 0x68e <BCD_5Int+0x76>
 68c:	20 e3       	ldi	r18, 0x30	; 48
 68e:	20 93 74 00 	sts	0x0074, r18
	
	value += BCD_SYMBOL;
 692:	c0 96       	adiw	r24, 0x30	; 48
	BCD_SaveDataInBuf(value, buf, i);
 694:	80 93 75 00 	sts	0x0075, r24
 698:	85 e0       	ldi	r24, 0x05	; 5
 69a:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 69e:	10 92 76 00 	sts	0x0076, r1
	BCD_SendData(value);
}
 6a2:	08 95       	ret

000006a4 <BCD_Uchar>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;
	
	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 100);
 6a4:	90 e0       	ldi	r25, 0x00	; 0
 6a6:	02 c0       	rjmp	.+4      	; 0x6ac <BCD_Uchar+0x8>
 6a8:	9f 5f       	subi	r25, 0xFF	; 255
 6aa:	84 56       	subi	r24, 0x64	; 100
 6ac:	84 36       	cpi	r24, 0x64	; 100
 6ae:	e0 f7       	brcc	.-8      	; 0x6a8 <BCD_Uchar+0x4>
 6b0:	99 23       	and	r25, r25
 6b2:	11 f0       	breq	.+4      	; 0x6b8 <BCD_Uchar+0x14>
 6b4:	90 5d       	subi	r25, 0xD0	; 208
 6b6:	01 c0       	rjmp	.+2      	; 0x6ba <BCD_Uchar+0x16>
 6b8:	90 e3       	ldi	r25, 0x30	; 48
 6ba:	90 93 71 00 	sts	0x0071, r25
	BCD_Calc(digit, value, flag, buf, i, 10);
 6be:	90 e0       	ldi	r25, 0x00	; 0
 6c0:	02 c0       	rjmp	.+4      	; 0x6c6 <BCD_Uchar+0x22>
 6c2:	9f 5f       	subi	r25, 0xFF	; 255
 6c4:	8a 50       	subi	r24, 0x0A	; 10
 6c6:	8a 30       	cpi	r24, 0x0A	; 10
 6c8:	e0 f7       	brcc	.-8      	; 0x6c2 <BCD_Uchar+0x1e>
 6ca:	99 23       	and	r25, r25
 6cc:	11 f0       	breq	.+4      	; 0x6d2 <BCD_Uchar+0x2e>
 6ce:	90 5d       	subi	r25, 0xD0	; 208
 6d0:	01 c0       	rjmp	.+2      	; 0x6d4 <BCD_Uchar+0x30>
 6d2:	90 e3       	ldi	r25, 0x30	; 48
 6d4:	90 93 72 00 	sts	0x0072, r25
	
	value += BCD_SYMBOL;
 6d8:	80 5d       	subi	r24, 0xD0	; 208
	BCD_SaveDataInBuf(value, buf, i);
 6da:	80 93 73 00 	sts	0x0073, r24
 6de:	83 e0       	ldi	r24, 0x03	; 3
 6e0:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 6e4:	10 92 74 00 	sts	0x0074, r1
	BCD_SendData(value);
}
 6e8:	08 95       	ret

000006ea <BCD_Uint>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;

	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 10000);
 6ea:	20 e0       	ldi	r18, 0x00	; 0
 6ec:	03 c0       	rjmp	.+6      	; 0x6f4 <BCD_Uint+0xa>
 6ee:	2f 5f       	subi	r18, 0xFF	; 255
 6f0:	80 51       	subi	r24, 0x10	; 16
 6f2:	97 42       	sbci	r25, 0x27	; 39
 6f4:	37 e2       	ldi	r19, 0x27	; 39
 6f6:	80 31       	cpi	r24, 0x10	; 16
 6f8:	93 07       	cpc	r25, r19
 6fa:	c8 f7       	brcc	.-14     	; 0x6ee <BCD_Uint+0x4>
 6fc:	22 23       	and	r18, r18
 6fe:	11 f0       	breq	.+4      	; 0x704 <BCD_Uint+0x1a>
 700:	20 5d       	subi	r18, 0xD0	; 208
 702:	01 c0       	rjmp	.+2      	; 0x706 <BCD_Uint+0x1c>
 704:	20 e3       	ldi	r18, 0x30	; 48
 706:	20 93 71 00 	sts	0x0071, r18
	BCD_Calc(digit, value, flag, buf, i, 1000);
 70a:	20 e0       	ldi	r18, 0x00	; 0
 70c:	03 c0       	rjmp	.+6      	; 0x714 <BCD_Uint+0x2a>
 70e:	2f 5f       	subi	r18, 0xFF	; 255
 710:	88 5e       	subi	r24, 0xE8	; 232
 712:	93 40       	sbci	r25, 0x03	; 3
 714:	33 e0       	ldi	r19, 0x03	; 3
 716:	88 3e       	cpi	r24, 0xE8	; 232
 718:	93 07       	cpc	r25, r19
 71a:	c8 f7       	brcc	.-14     	; 0x70e <BCD_Uint+0x24>
 71c:	22 23       	and	r18, r18
 71e:	11 f0       	breq	.+4      	; 0x724 <BCD_Uint+0x3a>
 720:	20 5d       	subi	r18, 0xD0	; 208
 722:	01 c0       	rjmp	.+2      	; 0x726 <BCD_Uint+0x3c>
 724:	20 e3       	ldi	r18, 0x30	; 48
 726:	20 93 72 00 	sts	0x0072, r18
	BCD_Calc(digit, value, flag, buf, i, 100);
 72a:	20 e0       	ldi	r18, 0x00	; 0
 72c:	03 c0       	rjmp	.+6      	; 0x734 <BCD_Uint+0x4a>
 72e:	2f 5f       	subi	r18, 0xFF	; 255
 730:	84 56       	subi	r24, 0x64	; 100
 732:	90 40       	sbci	r25, 0x00	; 0
 734:	84 36       	cpi	r24, 0x64	; 100
 736:	91 05       	cpc	r25, r1
 738:	d0 f7       	brcc	.-12     	; 0x72e <BCD_Uint+0x44>
 73a:	22 23       	and	r18, r18
 73c:	11 f0       	breq	.+4      	; 0x742 <BCD_Uint+0x58>
 73e:	20 5d       	subi	r18, 0xD0	; 208
 740:	01 c0       	rjmp	.+2      	; 0x744 <BCD_Uint+0x5a>
 742:	20 e3       	ldi	r18, 0x30	; 48
 744:	20 93 73 00 	sts	0x0073, r18
	BCD_Calc(digit, value, flag, buf, i, 10);
 748:	20 e0       	ldi	r18, 0x00	; 0
 74a:	02 c0       	rjmp	.+4      	; 0x750 <BCD_Uint+0x66>
 74c:	2f 5f       	subi	r18, 0xFF	; 255
 74e:	0a 97       	sbiw	r24, 0x0a	; 10
 750:	8a 30       	cpi	r24, 0x0A	; 10
 752:	91 05       	cpc	r25, r1
 754:	d8 f7       	brcc	.-10     	; 0x74c <BCD_Uint+0x62>
 756:	22 23       	and	r18, r18
 758:	11 f0       	breq	.+4      	; 0x75e <BCD_Uint+0x74>
 75a:	20 5d       	subi	r18, 0xD0	; 208
 75c:	01 c0       	rjmp	.+2      	; 0x760 <BCD_Uint+0x76>
 75e:	20 e3       	ldi	r18, 0x30	; 48
 760:	20 93 74 00 	sts	0x0074, r18
	
	value += BCD_SYMBOL;
 764:	c0 96       	adiw	r24, 0x30	; 48
	BCD_SaveDataInBuf(value, buf, i);
 766:	80 93 75 00 	sts	0x0075, r24
 76a:	85 e0       	ldi	r24, 0x05	; 5
 76c:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 770:	10 92 76 00 	sts	0x0076, r1
	BCD_SendData(value);
}
 774:	08 95       	ret

00000776 <BCD_Ulong>:
	uint8_t digit, flag;
	
	flag = SYMB_NULL;

	BCD_InitIndexBuf(i);
	BCD_Calc(digit, value, flag, buf, i, 1000000000);
 776:	20 e0       	ldi	r18, 0x00	; 0
 778:	05 c0       	rjmp	.+10     	; 0x784 <BCD_Ulong+0xe>
 77a:	2f 5f       	subi	r18, 0xFF	; 255
 77c:	60 50       	subi	r22, 0x00	; 0
 77e:	7a 4c       	sbci	r23, 0xCA	; 202
 780:	8a 49       	sbci	r24, 0x9A	; 154
 782:	9b 43       	sbci	r25, 0x3B	; 59
 784:	60 30       	cpi	r22, 0x00	; 0
 786:	3a ec       	ldi	r19, 0xCA	; 202
 788:	73 07       	cpc	r23, r19
 78a:	3a e9       	ldi	r19, 0x9A	; 154
 78c:	83 07       	cpc	r24, r19
 78e:	3b e3       	ldi	r19, 0x3B	; 59
 790:	93 07       	cpc	r25, r19
 792:	98 f7       	brcc	.-26     	; 0x77a <BCD_Ulong+0x4>
 794:	22 23       	and	r18, r18
 796:	11 f0       	breq	.+4      	; 0x79c <BCD_Ulong+0x26>
 798:	20 5d       	subi	r18, 0xD0	; 208
 79a:	01 c0       	rjmp	.+2      	; 0x79e <BCD_Ulong+0x28>
 79c:	20 e3       	ldi	r18, 0x30	; 48
 79e:	20 93 71 00 	sts	0x0071, r18
	BCD_Calc(digit, value, flag, buf, i, 100000000);
 7a2:	20 e0       	ldi	r18, 0x00	; 0
 7a4:	05 c0       	rjmp	.+10     	; 0x7b0 <BCD_Ulong+0x3a>
 7a6:	2f 5f       	subi	r18, 0xFF	; 255
 7a8:	60 50       	subi	r22, 0x00	; 0
 7aa:	71 4e       	sbci	r23, 0xE1	; 225
 7ac:	85 4f       	sbci	r24, 0xF5	; 245
 7ae:	95 40       	sbci	r25, 0x05	; 5
 7b0:	60 30       	cpi	r22, 0x00	; 0
 7b2:	31 ee       	ldi	r19, 0xE1	; 225
 7b4:	73 07       	cpc	r23, r19
 7b6:	35 ef       	ldi	r19, 0xF5	; 245
 7b8:	83 07       	cpc	r24, r19
 7ba:	35 e0       	ldi	r19, 0x05	; 5
 7bc:	93 07       	cpc	r25, r19
 7be:	98 f7       	brcc	.-26     	; 0x7a6 <BCD_Ulong+0x30>
 7c0:	22 23       	and	r18, r18
 7c2:	11 f0       	breq	.+4      	; 0x7c8 <BCD_Ulong+0x52>
 7c4:	20 5d       	subi	r18, 0xD0	; 208
 7c6:	01 c0       	rjmp	.+2      	; 0x7ca <BCD_Ulong+0x54>
 7c8:	20 e3       	ldi	r18, 0x30	; 48
 7ca:	20 93 72 00 	sts	0x0072, r18
	BCD_Calc(digit, value, flag, buf, i, 10000000);
 7ce:	20 e0       	ldi	r18, 0x00	; 0
 7d0:	05 c0       	rjmp	.+10     	; 0x7dc <BCD_Ulong+0x66>
 7d2:	2f 5f       	subi	r18, 0xFF	; 255
 7d4:	60 58       	subi	r22, 0x80	; 128
 7d6:	76 49       	sbci	r23, 0x96	; 150
 7d8:	88 49       	sbci	r24, 0x98	; 152
 7da:	90 40       	sbci	r25, 0x00	; 0
 7dc:	60 38       	cpi	r22, 0x80	; 128
 7de:	36 e9       	ldi	r19, 0x96	; 150
 7e0:	73 07       	cpc	r23, r19
 7e2:	38 e9       	ldi	r19, 0x98	; 152
 7e4:	83 07       	cpc	r24, r19
 7e6:	30 e0       	ldi	r19, 0x00	; 0
 7e8:	93 07       	cpc	r25, r19
 7ea:	98 f7       	brcc	.-26     	; 0x7d2 <BCD_Ulong+0x5c>
 7ec:	22 23       	and	r18, r18
 7ee:	11 f0       	breq	.+4      	; 0x7f4 <BCD_Ulong+0x7e>
 7f0:	20 5d       	subi	r18, 0xD0	; 208
 7f2:	01 c0       	rjmp	.+2      	; 0x7f6 <BCD_Ulong+0x80>
 7f4:	20 e3       	ldi	r18, 0x30	; 48
 7f6:	20 93 73 00 	sts	0x0073, r18
	BCD_Calc(digit, value, flag, buf, i, 1000000);
 7fa:	20 e0       	ldi	r18, 0x00	; 0
 7fc:	05 c0       	rjmp	.+10     	; 0x808 <BCD_Ulong+0x92>
 7fe:	2f 5f       	subi	r18, 0xFF	; 255
 800:	60 54       	subi	r22, 0x40	; 64
 802:	72 44       	sbci	r23, 0x42	; 66
 804:	8f 40       	sbci	r24, 0x0F	; 15
 806:	90 40       	sbci	r25, 0x00	; 0
 808:	60 34       	cpi	r22, 0x40	; 64
 80a:	32 e4       	ldi	r19, 0x42	; 66
 80c:	73 07       	cpc	r23, r19
 80e:	3f e0       	ldi	r19, 0x0F	; 15
 810:	83 07       	cpc	r24, r19
 812:	30 e0       	ldi	r19, 0x00	; 0
 814:	93 07       	cpc	r25, r19
 816:	98 f7       	brcc	.-26     	; 0x7fe <BCD_Ulong+0x88>
 818:	22 23       	and	r18, r18
 81a:	11 f0       	breq	.+4      	; 0x820 <BCD_Ulong+0xaa>
 81c:	20 5d       	subi	r18, 0xD0	; 208
 81e:	01 c0       	rjmp	.+2      	; 0x822 <BCD_Ulong+0xac>
 820:	20 e3       	ldi	r18, 0x30	; 48
 822:	20 93 74 00 	sts	0x0074, r18
	BCD_Calc(digit, value, flag, buf, i, 100000);
 826:	20 e0       	ldi	r18, 0x00	; 0
 828:	05 c0       	rjmp	.+10     	; 0x834 <BCD_Ulong+0xbe>
 82a:	2f 5f       	subi	r18, 0xFF	; 255
 82c:	60 5a       	subi	r22, 0xA0	; 160
 82e:	76 48       	sbci	r23, 0x86	; 134
 830:	81 40       	sbci	r24, 0x01	; 1
 832:	90 40       	sbci	r25, 0x00	; 0
 834:	60 3a       	cpi	r22, 0xA0	; 160
 836:	36 e8       	ldi	r19, 0x86	; 134
 838:	73 07       	cpc	r23, r19
 83a:	31 e0       	ldi	r19, 0x01	; 1
 83c:	83 07       	cpc	r24, r19
 83e:	30 e0       	ldi	r19, 0x00	; 0
 840:	93 07       	cpc	r25, r19
 842:	98 f7       	brcc	.-26     	; 0x82a <BCD_Ulong+0xb4>
 844:	22 23       	and	r18, r18
 846:	11 f0       	breq	.+4      	; 0x84c <BCD_Ulong+0xd6>
 848:	20 5d       	subi	r18, 0xD0	; 208
 84a:	01 c0       	rjmp	.+2      	; 0x84e <BCD_Ulong+0xd8>
 84c:	20 e3       	ldi	r18, 0x30	; 48
 84e:	20 93 75 00 	sts	0x0075, r18
	BCD_Calc(digit, value, flag, buf, i, 10000);
 852:	20 e0       	ldi	r18, 0x00	; 0
 854:	05 c0       	rjmp	.+10     	; 0x860 <BCD_Ulong+0xea>
 856:	2f 5f       	subi	r18, 0xFF	; 255
 858:	60 51       	subi	r22, 0x10	; 16
 85a:	77 42       	sbci	r23, 0x27	; 39
 85c:	80 40       	sbci	r24, 0x00	; 0
 85e:	90 40       	sbci	r25, 0x00	; 0
 860:	60 31       	cpi	r22, 0x10	; 16
 862:	37 e2       	ldi	r19, 0x27	; 39
 864:	73 07       	cpc	r23, r19
 866:	30 e0       	ldi	r19, 0x00	; 0
 868:	83 07       	cpc	r24, r19
 86a:	30 e0       	ldi	r19, 0x00	; 0
 86c:	93 07       	cpc	r25, r19
 86e:	98 f7       	brcc	.-26     	; 0x856 <BCD_Ulong+0xe0>
 870:	22 23       	and	r18, r18
 872:	11 f0       	breq	.+4      	; 0x878 <BCD_Ulong+0x102>
 874:	20 5d       	subi	r18, 0xD0	; 208
 876:	01 c0       	rjmp	.+2      	; 0x87a <BCD_Ulong+0x104>
 878:	20 e3       	ldi	r18, 0x30	; 48
 87a:	20 93 76 00 	sts	0x0076, r18
	BCD_Calc(digit, value, flag, buf, i, 1000);
 87e:	20 e0       	ldi	r18, 0x00	; 0
 880:	05 c0       	rjmp	.+10     	; 0x88c <BCD_Ulong+0x116>
 882:	2f 5f       	subi	r18, 0xFF	; 255
 884:	68 5e       	subi	r22, 0xE8	; 232
 886:	73 40       	sbci	r23, 0x03	; 3
 888:	80 40       	sbci	r24, 0x00	; 0
 88a:	90 40       	sbci	r25, 0x00	; 0
 88c:	68 3e       	cpi	r22, 0xE8	; 232
 88e:	33 e0       	ldi	r19, 0x03	; 3
 890:	73 07       	cpc	r23, r19
 892:	30 e0       	ldi	r19, 0x00	; 0
 894:	83 07       	cpc	r24, r19
 896:	30 e0       	ldi	r19, 0x00	; 0
 898:	93 07       	cpc	r25, r19
 89a:	98 f7       	brcc	.-26     	; 0x882 <BCD_Ulong+0x10c>
 89c:	22 23       	and	r18, r18
 89e:	11 f0       	breq	.+4      	; 0x8a4 <BCD_Ulong+0x12e>
 8a0:	20 5d       	subi	r18, 0xD0	; 208
 8a2:	01 c0       	rjmp	.+2      	; 0x8a6 <BCD_Ulong+0x130>
 8a4:	20 e3       	ldi	r18, 0x30	; 48
 8a6:	20 93 77 00 	sts	0x0077, r18
	BCD_Calc(digit, value, flag, buf, i, 100);
 8aa:	20 e0       	ldi	r18, 0x00	; 0
 8ac:	05 c0       	rjmp	.+10     	; 0x8b8 <BCD_Ulong+0x142>
 8ae:	2f 5f       	subi	r18, 0xFF	; 255
 8b0:	64 56       	subi	r22, 0x64	; 100
 8b2:	70 40       	sbci	r23, 0x00	; 0
 8b4:	80 40       	sbci	r24, 0x00	; 0
 8b6:	90 40       	sbci	r25, 0x00	; 0
 8b8:	64 36       	cpi	r22, 0x64	; 100
 8ba:	71 05       	cpc	r23, r1
 8bc:	81 05       	cpc	r24, r1
 8be:	91 05       	cpc	r25, r1
 8c0:	b0 f7       	brcc	.-20     	; 0x8ae <BCD_Ulong+0x138>
 8c2:	22 23       	and	r18, r18
 8c4:	11 f0       	breq	.+4      	; 0x8ca <BCD_Ulong+0x154>
 8c6:	20 5d       	subi	r18, 0xD0	; 208
 8c8:	01 c0       	rjmp	.+2      	; 0x8cc <BCD_Ulong+0x156>
 8ca:	20 e3       	ldi	r18, 0x30	; 48
 8cc:	20 93 78 00 	sts	0x0078, r18
	BCD_Calc(digit, value, flag, buf, i, 10);
 8d0:	20 e0       	ldi	r18, 0x00	; 0
 8d2:	05 c0       	rjmp	.+10     	; 0x8de <BCD_Ulong+0x168>
 8d4:	2f 5f       	subi	r18, 0xFF	; 255
 8d6:	6a 50       	subi	r22, 0x0A	; 10
 8d8:	70 40       	sbci	r23, 0x00	; 0
 8da:	80 40       	sbci	r24, 0x00	; 0
 8dc:	90 40       	sbci	r25, 0x00	; 0
 8de:	6a 30       	cpi	r22, 0x0A	; 10
 8e0:	71 05       	cpc	r23, r1
 8e2:	81 05       	cpc	r24, r1
 8e4:	91 05       	cpc	r25, r1
 8e6:	b0 f7       	brcc	.-20     	; 0x8d4 <BCD_Ulong+0x15e>
 8e8:	22 23       	and	r18, r18
 8ea:	11 f0       	breq	.+4      	; 0x8f0 <BCD_Ulong+0x17a>
 8ec:	20 5d       	subi	r18, 0xD0	; 208
 8ee:	01 c0       	rjmp	.+2      	; 0x8f2 <BCD_Ulong+0x17c>
 8f0:	20 e3       	ldi	r18, 0x30	; 48
 8f2:	20 93 79 00 	sts	0x0079, r18
	
	value += BCD_SYMBOL;
 8f6:	60 5d       	subi	r22, 0xD0	; 208
 8f8:	7f 4f       	sbci	r23, 0xFF	; 255
 8fa:	8f 4f       	sbci	r24, 0xFF	; 255
 8fc:	9f 4f       	sbci	r25, 0xFF	; 255
	BCD_SaveDataInBuf(value, buf, i);
 8fe:	60 93 7a 00 	sts	0x007A, r22
 902:	8a e0       	ldi	r24, 0x0A	; 10
 904:	80 93 70 00 	sts	0x0070, r24
	BCD_AddEndStrInBuf(0, buf, i);
 908:	10 92 7b 00 	sts	0x007B, r1
	BCD_SendData(value);
}
 90c:	08 95       	ret

0000090e <_exit>:
 90e:	f8 94       	cli

00000910 <__stop_program>:
 910:	ff cf       	rjmp	.-2      	; 0x910 <__stop_program>
