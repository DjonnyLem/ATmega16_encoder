#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "LCD.h"           //Хедер для LCD дисплея



#define F_CPU 8000000UL
//#define Enc_PORT 	PORTD 	//
//#define Enc_DDR 	DDRD	//
//#define Enc_PIN 	PIND	//
//#define Enc_A		PD2		//
//#define Enc_B		PD1		//

#define COUNT_TIMER 79    // значение счетчика таймера для прерывания COUNT_TIMER 8 ~ каждые 1mc; COUNT_TIMER 78 ~ каждые 10mc
#define LED_PORT 	PORTD
#define LED_DDR 	DDRD 
#define LED_PIN		PIND
#define	LED1 		7	

#define  BLINK 30		//значение счетчика периода мигания светодиода. 



unsigned int	 	CountLED = BLINK;			// Cчетчик импульсов LED. Считает по прерываниям таймера  30*10mc =0,3сек

unsigned int	 	Count = 0;		//просто счетчик, значение которого будем выводить на дисплей
unsigned int		count1 = 100;	//просто счетчик, обеспечивающий работу счетчика Count примерно раз в 1сек
uint8_t *pBuf; // определяем переменную указатель на буфер (нужно для обображения вывода чисел??)

struct flag 
{
	_Bool LED	:1;		//Флаг LED диода. Флаг установлен- счетчик BLINK досчитал до установленного значения
}Flag;


/********************************************************************
* Обработчик прерывания таймера по совпадению
*********************************************************************/
ISR(TIMER0_COMP_vect)		//Обработчик прерывания таймера по совпадению
	{
		cli();					//запрещаем прерывания
		if (CountLED != 0)		// если значение счетчика CountLED не равно 0...
		{
			CountLED--;			// то значение счетчика уменьшаем на 1

		}
		else 				// иначе
		{
			Flag.LED = 1;		// устанавливаем 1 во флаге flag.LED
			CountLED = BLINK;	// присваиваем счетчику CountLED значение BLINK
		
		}

		asm("nop");				//просто заглушка 
		sei();					// разрешаем прерывание
	}


/********************************************************************
* 	Основной цикл
*********************************************************************/

int main(void)
{
	LCDinit();      //Инициализация LCD
	Init_TIMER0_COMP(); //Инициализация таймера
    Init_Port();		//Инициализация портов
	
	pBuf=BCD_GetPointerBuf();//иннициализация переменной pBuf для вывода данных на LCD
	OCR0 = COUNT_TIMER; //Заносим регистр значение счетчика
    TCNT0 =0;			//Сбрасываем таймер
    sei();								// Общее разрешение прерываний
	while(1)
	{
		
		if (Flag.LED  == 1) //Проверяем, если флаг flag.LED принял значение 1
		{
			//ниже обработка счетчика
			count1--;	
			if (count1 == 0)
			{
				count1 =100;
				Count++;
				if (Count ==255)
				{
					Count = 0;
				};
			};
			//обработка счетчика завершено		
			Flag.LED = 0; 	//Устанавливаем во флаг flag.LED значение 0
			BlinkLED1(); //переход в функцию мигания светодиодом
			LCD_DATA(); //вывод данных на дисплей
		};
		asm("nop");
	};


};

/********************************************************************
* 	Инициализация таймера
*********************************************************************/
void Init_TIMER0_COMP(void)
{
	//=========================================================
	//  Т А Й М Е Р  Т0	 (Циклический отсчет 10 ms)
	//	Режим CTC	WGM01=1, WGM00=0;
	//	(1/8.000.000)*1024=0.000128
	//	0.001 sec/0.000128=7,8 тактов в 1ms - #define COUNT_TIMER 8 или 79 тактов в 10mc
	//	
	//=========================================================
//			  7       6       5       4       3      2        1	
//	TCCR0 = FOC00 | WGM00 | COM01 | COM00 | CS02 | CS01 |	CS00

	//CS02,CS01,CS00 ПРЕСКАЛЕР 101 -1024; 001 -0; 010 -8; 011 -64; 100 -256
	//(1<<WGM01) | (0<<WGM00) CTC РЕЖИМ
	TCCR0 |=(1<<CS02)|(0<<CS01)|(1<<CS00)|(1<<WGM01)|(0<<WGM00);  	
																			


//TIMSK 
	//; TOIE01- РАЗРЕШАЕТ ПРЕРЫВАНИЕ ПО ПЕРЕПОЛНЕНИЮ, 0- ЗАПРЕЩАЕТ / OCIE0 1- РАЗРЕШАЕТ ПРЕРЫВАНИЕ ПО СОВПАДЕНИЮ, 0- ЗАПРЕЩАЕТ
	TIMSK |=(0<<TOIE0)|(1<<OCIE0); 
	
    TIFR |= (1<<OCF0)|(0<<TOV0);
};	
	
void Init_Port(void)
{
	

/********************************************************************
* 	ИНИЦИАЛИЗАЦИЯ ПОРТОВ
*********************************************************************/

	
	LED_DDR |= 1<<LED1; // БИТ ПОРТА D НА ВЫХОД
	LED_PORT |= 1<<LED1; //УСТАНАВЛИВАЕМ В БИТЕ ПОРТА D ВЫСОКИЙ УРОВЕНЬ

//	Enc_DDR &= (~(1<<Enc_A) | (1<<Enc_B)); // БИТ ПОРТА D НА ВХОД
//	Enc_PORT &= (~(1<<Enc_A) | (1<<Enc_B)); //УСТАНАВЛИВАЕМ В БИТЕ ПОРТА D ПОДТЯЖКУ
	
//	DDRA = 0b00000000; // БИТ ПОРТА A НА ВХОД
//	PORTA = 0b00000001; //УСТАНАВЛИВАЕМ В БИТЕ ПОРТА A ПОДТЯЖКУ
};	
	

/********************************************************************
* 	РАБОТА ДИОДА LED1
*********************************************************************/
void BlinkLED1 (void)
{
	
	if (bit_is_set (LED_PIN, LED1)) // если бит LED1 в порту LED_PIN установлен
	{
		LED_PORT &= ~(1<<LED1);		// устанавливаем 0 в бите LED1
	}
    else							// иначе
	{
		LED_PORT |= 1<<LED1;		//устанавливаем 1 в бите LED1
	};

};

void LCD_DATA (void)
{
		LCDstringXY("Count:",0,0);
		LCDstringXY("Volt:",0,1);
		
		BCD_5Int(Count);
		LCDstring_of_sramXY(pBuf,8,0);
		
		//BCD_5Int(value_ADC);
		//LCDstring_of_sramXY(pBuf,8,1);
		
        //asm("nop");
		//LCDstringXY(EncValueValue,5,1);
};


